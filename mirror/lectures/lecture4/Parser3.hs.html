<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>lectures/lecture4/Parser3.hs</title>
</head>
<body>
<pre><font color=Blue>{-# LANGUAGE GADTs #-}</font>

<font color=Blue>-- | Removing the constructor for (+++)</font>
<u><font color="#804000">module</font></u> <font color=Green>Parser3</font>
  <font color="#808080">(</font> <font color=Green>P</font>           <font color=Blue>-- :: * -&gt; * -&gt; *</font>
  <font color="#808080">,</font> symbol      <font color=Blue>-- :: P s s</font>
  <font color="#808080">,</font> pfail       <font color=Blue>-- :: P s a</font>
  <font color="#808080">,</font> <font color="#808080">(</font><font color="#800080">+++</font><font color="#808080">)</font>       <font color=Blue>-- :: P s a -&gt; P s a -&gt; P s a</font>
  <font color="#808080">,</font> <font color=Green>ParseResult</font> <font color=Blue>-- ParseResult s a = [(a, [s])]</font>
  <font color="#808080">,</font> parse       <font color=Blue>-- :: P s a -&gt; [s] -&gt; ParseResult s a</font>
  <font color="#808080">)</font> <u><font color="#804000">where</font></u>
<u><font color="#804000">import</font></u> <font color=Green>Control</font><font color="#800080">.</font><font color=Green>Monad</font><font color="#808080">(</font><font color="#808080">(</font><font color="#800080">&gt;=&gt;</font><font color="#808080">)</font><font color="#808080">)</font>

<u><font color="#804000">type</font></u> <font color=Green>ParseResult</font> s a <font color="#808080">=</font> <font color="#808080">[</font><font color="#808080">(</font>a<font color="#808080">,</font> <font color="#808080">[</font>s<font color="#808080">]</font><font color="#808080">)</font><font color="#808080">]</font>

<font color=Blue>{-| The second problem was the use of (++) when parsing a
  choice. To fix this we'll remove the (:+++) constructor. (We
  linearize the choice operation). Let's look at the laws that
  might be useful:

    L6.  fail +++ q       ==  q
    L7.  p +++ fail       ==  p
    L8.  (p +++ q) +++ r  ==  p +++ (q +++ r)
    L9.  p +++ q          ==  q +++ p
    L10. (symbol &gt;&gt;= f) +++ (symbol &gt;&gt;= g)
                          ==  symbol &gt;&gt;= (\c -&gt; f c +++ g c)

  We seem to have laws about (+++) for all possible arguments
  except return, hence we add a constructor for this special
  case and get rid of the general choice.

      ReturnChoice x p == return x +++ p

  Note that since (+++) is commutative we don't need a
  constructor for p +++ return x. Using multisets is paying off!

  Using L7 we can get rid of the Return constructor as well:

      return x  ==  return x +++ fail  ==  ReturnChoice Fail
-}</font>
<u><font color="#804000">data</font></u> <font color=Green>P</font> s a <u><font color="#804000">where</font></u>
  <font color=Green>Fail</font>         <font color="#808080">::</font>                 <font color=Green>P</font> s a
  <font color=Green>ReturnChoice</font> <font color="#808080">::</font> a <font color="#808080">-&gt;</font> <font color=Green>P</font> s a   <font color="#808080">-&gt;</font> <font color=Green>P</font> s a 
    <font color=Blue>-- ReturnChoice x p == return x +++ p</font>
  <font color=Green>SymbolBind</font>   <font color="#808080">::</font> <font color="#808080">(</font>s <font color="#808080">-&gt;</font> <font color=Green>P</font> s a<font color="#808080">)</font> <font color="#808080">-&gt;</font> <font color=Green>P</font> s a 
    <font color=Blue>-- SymbolBind f     == symbol &gt;&gt;= f</font>

symbol <font color="#808080">::</font> <font color=Green>P</font> s s
symbol <font color="#808080">=</font> <font color=Green>SymbolBind</font> return

pfail <font color="#808080">::</font> <font color=Green>P</font> s a
pfail  <font color="#808080">=</font> <font color=Green>Fail</font>

<font color=Blue>{-| Using the laws listed above we can derive the implementation
  of (+++). Note the use of associativity and commutativity of
  (+++) in the last two clauses.

  In a stroke of luck, while removing the (:+++) constructor we
  also got rid of the space leak introduced by backtracking.
  Looking at the first clause, we see that this choice operator
  runs its arguments in parallel -- if both sides in a choice
  want to consume a symbol then we consume a symbol once and
  feed it to both parsers, rather than as before running the
  first parser to completion before feeding the second parser.

-}</font>
<font color="#808080">(</font><font color="#800080">+++</font><font color="#808080">)</font> <font color="#808080">::</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color=Green>P</font> s a
<font color=Green>SymbolBind</font> f     <font color="#800080">+++</font> <font color=Green>SymbolBind</font> g     <font color="#808080">=</font> <font color=Green>SymbolBind</font> 
                                          <font color="#808080">(</font><font color="#808080">\</font>x <font color="#808080">-&gt;</font> f x <font color="#800080">+++</font> g x<font color="#808080">)</font>
<font color=Green>Fail</font>             <font color="#800080">+++</font> q                <font color="#808080">=</font> q
p                <font color="#800080">+++</font> <font color=Green>Fail</font>             <font color="#808080">=</font> p
<font color=Green>ReturnChoice</font> x p <font color="#800080">+++</font> q                <font color="#808080">=</font> <font color=Green>ReturnChoice</font> x <font color="#808080">(</font>p <font color="#800080">+++</font> q<font color="#808080">)</font>
p                <font color="#800080">+++</font> <font color=Green>ReturnChoice</font> x q <font color="#808080">=</font> <font color=Green>ReturnChoice</font> x <font color="#808080">(</font>p <font color="#800080">+++</font> q<font color="#808080">)</font>

bind <font color="#808080">::</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color="#808080">(</font>a <font color="#808080">-&gt;</font> <font color=Green>P</font> s b<font color="#808080">)</font> <font color="#808080">-&gt;</font> <font color=Green>P</font> s b
bind <font color=Green>Fail</font>                f  <font color="#808080">=</font>  <font color=Green>Fail</font>
bind <font color="#808080">(</font><font color=Green>ReturnChoice</font> x p<font color="#808080">)</font>  f  <font color="#808080">=</font>  f x <font color="#800080">+++</font> <font color="#808080">(</font>p <font color="#800080">&gt;&gt;=</font> f<font color="#808080">)</font> <font color=Blue>-- see below</font>
bind <font color="#808080">(</font><font color=Green>SymbolBind</font> k<font color="#808080">)</font>      f  <font color="#808080">=</font>  <font color=Green>SymbolBind</font> <font color="#808080">(</font>k <font color="#800080">&gt;=&gt;</font> f<font color="#808080">)</font>

<font color=Blue>{-| Deriving the ReturnChoice case using L5 and L1:

  bind (ReturnChoice x p) f       ==  -- by def.
  bind (return x +++ p)   f       ==  -- L5
  (return x &gt;&gt;= f) +++ (p &gt;&gt;= f)  ==  -- L1
  f x +++ (p &gt;&gt;= f)

-}</font>

<u><font color="#804000">instance</font></u> <font color=Green>Monad</font> <font color="#808080">(</font><font color=Green>P</font> s<font color="#808080">)</font> <u><font color="#804000">where</font></u>
  return x  <font color="#808080">=</font>  <font color=Green>ReturnChoice</font> x pfail
  <font color="#808080">(</font><font color="#800080">&gt;&gt;=</font><font color="#808080">)</font>     <font color="#808080">=</font>  bind

<font color=Blue>-- | Now the use of (++) has been replaced by a (:) and all our</font>
<font color=Blue>-- problems have gone away!</font>

parse <font color="#808080">::</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color="#808080">[</font>s<font color="#808080">]</font> <font color="#808080">-&gt;</font> <font color=Green>ParseResult</font> s a
parse <font color="#808080">(</font><font color=Green>SymbolBind</font> f<font color="#808080">)</font>      <font color="#808080">(</font>c <b><font color="#800080">:</font></b> s<font color="#808080">)</font>  <font color="#808080">=</font>  parse <font color="#808080">(</font>f c<font color="#808080">)</font> s
parse <font color="#808080">(</font><font color=Green>SymbolBind</font> f<font color="#808080">)</font>      <font color=Green>[]</font>       <font color="#808080">=</font>  <font color=Green>[]</font>
parse <font color=Green>Fail</font>                <u><font color="#804000">_</font></u>        <font color="#808080">=</font>  <font color=Green>[]</font>
parse <font color="#808080">(</font><font color=Green>ReturnChoice</font> x p<font color="#808080">)</font>  s        <font color="#808080">=</font>  <font color="#808080">(</font>x<font color="#808080">,</font> s<font color="#808080">)</font> <b><font color="#800080">:</font></b> parse p s

<font color=Blue>{- There is still one remaining source of inefficiency. If you
  look at the definition of (&gt;&gt;=), you'll see that it's linear
  in the size of its first argument. This means that we get a
  similar problem to the use of (++), namely a quadratic
  behaviour for left nested uses of (&gt;&gt;=). In order to fix this
  we cannot use the method we've been using so far, there is no
  constructor to remove to fix the problem. Instead we have to
  use another technique, called a "context passing"
  implementation. Read more about it in the paper.
-}</font>
</pre>
</body>
</html>