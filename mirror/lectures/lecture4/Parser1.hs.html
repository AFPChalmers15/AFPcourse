<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>lectures/lecture4/Parser1.hs</title>
</head>
<body>
<pre><font color=Blue>{-# LANGUAGE GADTs #-}</font>

<font color=Blue>-- | Naive deep embedding of the parsing library.</font>
<u><font color="#804000">module</font></u> <font color=Green>Parser1</font>
  <font color="#808080">(</font> <font color=Green>P</font>           <font color=Blue>-- :: * -&gt; * -&gt; *</font>
  <font color="#808080">,</font> symbol      <font color=Blue>-- :: P s s</font>
  <font color="#808080">,</font> pfail       <font color=Blue>-- :: P s a</font>
  <font color="#808080">,</font> <font color="#808080">(</font><font color="#800080">+++</font><font color="#808080">)</font>       <font color=Blue>-- :: P s a -&gt; P s a -&gt; P s a</font>
  <font color="#808080">,</font> <font color=Green>ParseResult</font> <font color=Blue>-- ParseResult s a = [(a, [s])]</font>
  <font color="#808080">,</font> parse       <font color=Blue>-- :: P s a -&gt; [s] -&gt; ParseResult s a</font>
  <font color="#808080">)</font> <u><font color="#804000">where</font></u>

<u><font color="#804000">type</font></u> <font color=Green>ParseResult</font> s a <font color="#808080">=</font> <font color="#808080">[</font><font color="#808080">(</font>a<font color="#808080">,</font> <font color="#808080">[</font>s<font color="#808080">]</font><font color="#808080">)</font><font color="#808080">]</font>
<u><font color="#804000">type</font></u> <font color=Green>PSem</font> s a  <font color="#808080">=</font>  <font color="#808080">[</font>s<font color="#808080">]</font> <font color="#808080">-&gt;</font> <font color=Green>ParseResult</font> s a

<font color=Blue>-- | Each operation is turned into a constructor.</font>
<u><font color="#804000">data</font></u> <font color=Green>P</font> s a <u><font color="#804000">where</font></u>
  <font color=Green>Symbol</font> <font color="#808080">::</font> <font color=Green>P</font> s s
  <font color=Green>Fail</font>   <font color="#808080">::</font> <font color=Green>P</font> s a
  <font color="#808080">(</font><b><font color="#800080">:+++</font></b><font color="#808080">)</font> <font color="#808080">::</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color=Green>P</font> s a
  <font color=Green>Return</font> <font color="#808080">::</font> a <font color="#808080">-&gt;</font> <font color=Green>P</font> s a
  <font color="#808080">(</font><b><font color="#800080">:&gt;&gt;=</font></b><font color="#808080">)</font> <font color="#808080">::</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color="#808080">(</font>a <font color="#808080">-&gt;</font> <font color=Green>P</font> s b<font color="#808080">)</font> <font color="#808080">-&gt;</font> <font color=Green>P</font> s b

symbol <font color="#808080">::</font> <font color=Green>P</font> s s
symbol <font color="#808080">=</font> <font color=Green>Symbol</font>

pfail <font color="#808080">::</font> <font color=Green>P</font> s a
pfail  <font color="#808080">=</font> <font color=Green>Fail</font>

<font color="#808080">(</font><font color="#800080">+++</font><font color="#808080">)</font> <font color="#808080">::</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color=Green>P</font> s a
<font color="#808080">(</font><font color="#800080">+++</font><font color="#808080">)</font>  <font color="#808080">=</font> <font color="#808080">(</font><b><font color="#800080">:+++</font></b><font color="#808080">)</font>

<u><font color="#804000">instance</font></u> <font color=Green>Monad</font> <font color="#808080">(</font><font color=Green>P</font> s<font color="#808080">)</font> <u><font color="#804000">where</font></u>
  return <font color="#808080">=</font> <font color=Green>Return</font>
  <font color="#808080">(</font><font color="#800080">&gt;&gt;=</font><font color="#808080">)</font>  <font color="#808080">=</font> <font color="#808080">(</font><b><font color="#800080">:&gt;&gt;=</font></b><font color="#808080">)</font>

<font color=Blue>-- | The parse function corresponds exactly to the semantics,</font>
<font color=Blue>--   except that we use lists instead of multisets.</font>
parse <font color="#808080">::</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color=Green>PSem</font> s a
parse <font color=Green>Symbol</font>      <font color="#808080">(</font>c <b><font color="#800080">:</font></b> s<font color="#808080">)</font>  <font color="#808080">=</font>  <font color="#808080">[</font><font color="#808080">(</font>c<font color="#808080">,</font> s<font color="#808080">)</font><font color="#808080">]</font>
parse <font color=Green>Symbol</font>      <font color=Green>[]</font>       <font color="#808080">=</font>  <font color=Green>[]</font>
parse <font color=Green>Fail</font>        <u><font color="#804000">_</font></u>        <font color="#808080">=</font>  <font color=Green>[]</font>
parse <font color="#808080">(</font>p <b><font color="#800080">:+++</font></b> q<font color="#808080">)</font>  s        <font color="#808080">=</font>  parse p s <font color="#800080">++</font> parse q s
parse <font color="#808080">(</font><font color=Green>Return</font> x<font color="#808080">)</font>  s        <font color="#808080">=</font>  <font color="#808080">[</font> <font color="#808080">(</font>x<font color="#808080">,</font> s<font color="#808080">)</font> <font color="#808080">]</font>
parse <font color="#808080">(</font>p <b><font color="#800080">:&gt;&gt;=</font></b> f<font color="#808080">)</font>  s        <font color="#808080">=</font>  bindS <font color="#808080">(</font>parse p<font color="#808080">)</font> <font color="#808080">(</font>parse <font color="#800080">.</font> f<font color="#808080">)</font> s


<font color=Blue>{- Here we have shortened the list comprehension from the
   semantics in Parser0.hs to simplify program calculation:

  [ (y, s'') | (x, s')  &lt;- parse p s
             , (y, s'') &lt;- parse (f x) s']
= { let q = parse p; g = parse . f; ys = (y, s'') }
  [ ys | (x, s')  &lt;- q s
       , ys       &lt;- g x s']
= { List comprehension translation }
  concatMap (\(x, s') -&gt; g x s') (q s)
= { def. uncurry }
  concatMap (uncurry g) (q s)
= { use this to define bindS }
  (q `bindS` g) s
-}</font>

bindS <font color="#808080">::</font> <font color=Green>PSem</font> s a <font color="#808080">-&gt;</font> <font color="#808080">(</font>a <font color="#808080">-&gt;</font> <font color=Green>PSem</font> s b<font color="#808080">)</font> <font color="#808080">-&gt;</font> <font color=Green>PSem</font> s b
q <font color="#800080">`bindS`</font> g <font color="#808080">=</font> concatMap <font color="#808080">(</font>uncurry g<font color="#808080">)</font> <font color="#800080">.</font> q


<font color=Blue>{- There are three sources of inefficiency that we can identify:

   1. The list comprehension builds a lot of intermediate lists
      which might be costly. (Partly fixed already.)

   2. List append (++) is linear in its first argument which
      means that left nested applications of (+++) get a
      quadratic behaviour.

   3. (+++) is treated in a depth first way, first computing the
      results of the left parser, then computing the results of
      the second parser. This leads to a space leak since we
      have to hang on to the input string to feed to the second
      parser, while traversing the string with the first parser.

  To fix these problems we'll use the laws stated in Parser0 to
  simplify our implementation.

-}</font>
</pre>
</body>
</html>