<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>lectures/lecture4/Parser0.hs</title>
</head>
<body>
<pre><font color=Blue>-- | The naive shallow embedding following the semantics, using </font>
<font color=Blue>--   lists to implement the multisets (also called bags).</font>
<u><font color="#804000">module</font></u> <font color=Green>Parser0</font>
  <font color="#808080">(</font> <font color=Green>P</font>           <font color=Blue>-- :: * -&gt; * -&gt; *</font>
  <font color="#808080">,</font> symbol      <font color=Blue>-- :: P s s</font>
  <font color="#808080">,</font> pfail       <font color=Blue>-- :: P s a</font>
  <font color="#808080">,</font> <font color="#808080">(</font><font color="#800080">+++</font><font color="#808080">)</font>       <font color=Blue>-- :: P s a -&gt; P s a -&gt; P s a</font>
  <font color="#808080">,</font> <font color=Green>PSem</font>        <font color=Blue>-- :: * -&gt; * -&gt; *</font>
  <font color="#808080">,</font> parse       <font color=Blue>-- :: P s a -&gt; PSem s a</font>
  <font color="#808080">)</font> <u><font color="#804000">where</font></u>

<font color=Blue>{-

The semantics of a parser of type 'P s a' is a function from a
string of 's' to a multiset of results paired with the remaining 
parts of the input string. We use a multiset to capture the fact
that we don't care about the order of the results.

The semantic function [| _ |], also called run, is defined as follows
(we use {| |} to denote multisets and \/ for multiset union).

[| _ |] :: P s a -&gt; [s] -&gt; {| (a, [s]) |}
[| symbol   |] (c : s) = {| (c, s) |}
[| symbol   |] []      = {| |}
[| pfail    |] s       = {| |}
[| p +++ q  |] s       = [| p |] s  \/  [| q |] s
[| return x |] s       = {| (x, s) |}
[| p &gt;&gt;= f  |] s       = {| (y, s'') | (x, s')  &lt;- [| p   |] s
                                     , (y, s'') &lt;- [| f x |] s'
                         |}

The RHS of the definition of bind can also be written 
  concatMap (uncurry (run . f)) (run p s)
which is more practical to calulate with.

Using this semantics we can prove (exercise) a number of useful
laws about parsers. We will use these laws later to derive an
efficient implementation of the library.

For two parsers p and q we define

  p == q  iff  forall s. [| p |] s == [| q |] s

Monad Laws

  L1.  return x &gt;&gt;= f   ==  f x
  L2.  p &gt;&gt;= return     ==  p
  L3.  (p &gt;&gt;= f) &gt;&gt;= g  ==  p &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)

More laws about &gt;&gt;=

  L4.  fail &gt;&gt;= f       ==  fail
  L5.  (p +++ q) &gt;&gt;= f  ==  (p &gt;&gt;= f) +++ (q &gt;&gt;= f)

Laws about (+++) and fail

  L6.  fail +++ q       ==  q
  L7.  p +++ fail       ==  p

Laws about (+++)

  L8.  (p +++ q) +++ r  ==  p +++ (q +++ r)
  L9.  p +++ q          ==  q +++ p   -- bag =&gt; order irrelevant

Laws about symbol

  L10. (symbol &gt;&gt;= f) +++ (symbol &gt;&gt;= g)
                        ==  symbol &gt;&gt;= (\c -&gt; f c +++ g c)

Here is the proof of L10 for the case of a non-empty input
string:

  [| (symbol &gt;&gt;= f) +++ (symbol &gt;&gt;= g) |] (c:s)         
==  { Def. of [| p +++ q |] }
  [| symbol &gt;&gt;= f |] (c:s)  \/  [| symbol &gt;&gt;= g |] (c:s)  
==  { Def. of [| p &gt;&gt;= f |] and [| symbol |] }
  [| f c |] s  \/  [| g c |] s                            
==  { Def. of [| p +++ q |] "backwards" }
  [| f c +++ g c |] s                                   
==  { Def. of [| p &gt;&gt;= f |] and [| symbol |] "backwards" }
  [| symbol &gt;&gt;= (\c -&gt; f c +++ g c) |] (c:s)

We can make a shallow embedding following the semantics, using
lists for the multisets.

-}</font>

<u><font color="#804000">type</font></u> <font color=Green>ParseResult</font> s a  <font color="#808080">=</font>  <font color="#808080">[</font><font color="#808080">(</font>a<font color="#808080">,</font> <font color="#808080">[</font>s<font color="#808080">]</font><font color="#808080">)</font><font color="#808080">]</font>
<u><font color="#804000">type</font></u> <font color=Green>PSem</font> s a  <font color="#808080">=</font>  <font color="#808080">[</font>s<font color="#808080">]</font> <font color="#808080">-&gt;</font> <font color=Green>ParseResult</font> s a

<font color=Blue>-- | We can implement parsers by their semantics (shallow embedding).</font>
<u><font color="#804000">newtype</font></u> <font color=Green>P</font> s a <font color="#808080">=</font> <font color=Green>P</font> <font color="#808080">(</font><font color=Green>PSem</font> s a<font color="#808080">)</font>

<font color=Blue>-- | The 'parse' function is trivial.</font>
parse <font color="#808080">::</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color=Green>PSem</font> s a
parse <font color="#808080">(</font><font color=Green>P</font> p<font color="#808080">)</font>  <font color="#808080">=</font>  p

<font color=Blue>-- The operations simply follow the semantics inserting the</font>
<font color=Blue>-- newtype constructor where appropriate.</font>

symbol <font color="#808080">::</font> <font color=Green>P</font> s s
symbol <font color="#808080">=</font> <font color=Green>P</font> symbolP 

symbolP <font color="#808080">::</font> <font color=Green>PSem</font> s s <font color=Blue>-- [s]   -&gt;  ParseResult s s</font>
symbolP  <font color="#808080">(</font>c <b><font color="#800080">:</font></b> s<font color="#808080">)</font>  <font color="#808080">=</font>  <font color="#808080">[</font><font color="#808080">(</font>c<font color="#808080">,</font> s<font color="#808080">)</font><font color="#808080">]</font>
symbolP  <font color=Green>[]</font>       <font color="#808080">=</font>  <font color=Green>[]</font>

pfail <font color="#808080">::</font> <font color=Green>P</font> s a
pfail <font color="#808080">=</font> <font color=Green>P</font> <font color="#800080">$</font> <font color="#808080">\</font><u><font color="#804000">_</font></u> <font color="#808080">-&gt;</font> <font color=Green>[]</font>

<font color="#808080">(</font><font color="#800080">+++</font><font color="#808080">)</font> <font color="#808080">::</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color=Green>P</font> s a
<font color=Green>P</font> p  <font color="#800080">+++</font>  <font color=Green>P</font> q  <font color="#808080">=</font>  <font color=Green>P</font> <font color="#808080">(</font>mplusP p q<font color="#808080">)</font>

mplusP <font color="#808080">::</font> <font color=Green>PSem</font> s a <font color="#808080">-&gt;</font> <font color=Green>PSem</font> s a <font color="#808080">-&gt;</font> <font color=Green>PSem</font> s a
mplusP p q  <font color="#808080">=</font>  <font color="#808080">\</font>s <font color="#808080">-&gt;</font>  p s <font color="#800080">++</font> q s

returnP <font color="#808080">::</font> a <font color="#808080">-&gt;</font> <font color=Green>PSem</font> s a 
returnP x <font color="#808080">=</font> <font color="#808080">\</font>s <font color="#808080">-&gt;</font> <font color="#808080">[</font><font color="#808080">(</font>x<font color="#808080">,</font> s<font color="#808080">)</font><font color="#808080">]</font>

bind <font color="#808080">::</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color="#808080">(</font>a <font color="#808080">-&gt;</font> <font color=Green>P</font> s b<font color="#808080">)</font> <font color="#808080">-&gt;</font> <font color=Green>P</font> s b
bind p f  <font color="#808080">=</font>  <font color=Green>P</font> <font color="#800080">$</font> <font color="#808080">\</font>s <font color="#808080">-&gt;</font> <font color="#808080">[</font> <font color="#808080">(</font>y<font color="#808080">,</font> s''<font color="#808080">)</font> 
                       <font color="#808080">|</font> <font color="#808080">(</font>x<font color="#808080">,</font> s'<font color="#808080">)</font>  <font color="#808080">&lt;-</font> parse p s
                       <font color="#808080">,</font> <font color="#808080">(</font>y<font color="#808080">,</font> s''<font color="#808080">)</font> <font color="#808080">&lt;-</font> parse <font color="#808080">(</font>f x<font color="#808080">)</font> s'
                       <font color="#808080">]</font>
<font color=Blue>-- or</font>
bind' <font color="#808080">::</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color="#808080">(</font>a <font color="#808080">-&gt;</font> <font color=Green>P</font> s b<font color="#808080">)</font> <font color="#808080">-&gt;</font> <font color=Green>P</font> s b
bind' p k  <font color="#808080">=</font>  <font color=Green>P</font> <font color="#800080">$</font> bindP <font color="#808080">(</font>parse p<font color="#808080">)</font> <font color="#808080">(</font>parse <font color="#800080">.</font> k<font color="#808080">)</font>

bindP <font color="#808080">::</font> <font color=Green>PSem</font> s a <font color="#808080">-&gt;</font> <font color="#808080">(</font>a <font color="#808080">-&gt;</font> <font color=Green>PSem</font> s b<font color="#808080">)</font> <font color="#808080">-&gt;</font> <font color=Green>PSem</font> s b
bindP p f <font color="#808080">=</font> concatMap <font color="#808080">(</font>uncurry f<font color="#808080">)</font> <font color="#800080">.</font> p

<u><font color="#804000">instance</font></u> <font color=Green>Monad</font> <font color="#808080">(</font><font color=Green>P</font> s<font color="#808080">)</font> <u><font color="#804000">where</font></u>
  return x  <font color="#808080">=</font>  <font color=Green>P</font> <font color="#800080">$</font> returnP x
  p <font color="#800080">&gt;&gt;=</font> f   <font color="#808080">=</font>  bind p f
  fail <u><font color="#804000">_</font></u>    <font color="#808080">=</font>  pfail


<font color=Blue>-- There are a number of efficiency problems with this</font>
<font color=Blue>-- implementation.  To solve them we'll start with a naive deep</font>
<font color=Blue>-- embedding and successively refine it to get something</font>
<font color=Blue>-- efficient.</font>
</pre>
</body>
</html>