<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>lectures/lecture4/Parsers.hs</title>
</head>
<body>
<pre><font color=Blue>{-# LANGUAGE GADTs #-}</font>
<u><font color="#804000">module</font></u> <font color=Green>Parsers</font>
  <font color="#808080">(</font> <font color=Green>P</font>           <font color=Blue>-- :: * -&gt; * -&gt; *</font>
  <font color="#808080">,</font> symbol      <font color=Blue>-- :: P s s</font>
  <font color="#808080">,</font> pfail       <font color=Blue>-- :: P s a</font>
  <font color="#808080">,</font> <font color="#808080">(</font><font color="#800080">+++</font><font color="#808080">)</font>       <font color=Blue>-- :: P s a -&gt; P s a -&gt; P s a</font>
  <font color="#808080">,</font> <font color=Green>Semantics</font>   <font color=Blue>-- :: * -&gt; * -&gt; *</font>
  <font color="#808080">,</font> parse       <font color=Blue>-- :: P s a -&gt; Semantics s a</font>
  <font color="#808080">)</font> <u><font color="#804000">where</font></u>

<font color=Blue>-- | Naive deep embedding: each operation is implemented as a</font>
<font color=Blue>--   constructor.</font>
<u><font color="#804000">type</font></u> <font color=Green>P</font> s a <font color="#808080">=</font> <font color=Green>Parser1</font> s a
symbol <font color="#808080">::</font> <font color=Green>P</font> s s
symbol <font color="#808080">=</font> <font color=Green>Symbol</font>

pfail <font color="#808080">::</font> <font color=Green>P</font> s a
pfail  <font color="#808080">=</font> <font color=Green>Fail</font>

<font color="#808080">(</font><font color="#800080">+++</font><font color="#808080">)</font> <font color="#808080">::</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color=Green>P</font> s a
<font color="#808080">(</font><font color="#800080">+++</font><font color="#808080">)</font>  <font color="#808080">=</font> <font color=Green>Choice</font>

<u><font color="#804000">instance</font></u> <font color=Green>Monad</font> <font color="#808080">(</font><font color=Green>Parser1</font> s<font color="#808080">)</font> <u><font color="#804000">where</font></u>
  return  <font color="#808080">=</font>  <font color=Green>Return</font>
  <font color="#808080">(</font><font color="#800080">&gt;&gt;=</font><font color="#808080">)</font>   <font color="#808080">=</font>  <font color="#808080">(</font><b><font color="#800080">:&gt;&gt;=</font></b><font color="#808080">)</font>

<u><font color="#804000">data</font></u> <font color=Green>Parser1</font> s a <u><font color="#804000">where</font></u>
  <font color=Green>Symbol</font>  <font color="#808080">::</font>  <font color=Green>Parser1</font> s s
  <font color=Green>Fail</font>    <font color="#808080">::</font>  <font color=Green>Parser1</font> s a
  <font color=Green>Choice</font>  <font color="#808080">::</font>  <font color=Green>Parser1</font> s a <font color="#808080">-&gt;</font> <font color=Green>Parser1</font> s a <font color="#808080">-&gt;</font> <font color=Green>Parser1</font> s a
  <font color=Green>Return</font>  <font color="#808080">::</font>  a <font color="#808080">-&gt;</font> <font color=Green>Parser1</font> s a
  <font color="#808080">(</font><b><font color="#800080">:&gt;&gt;=</font></b><font color="#808080">)</font>  <font color="#808080">::</font>  <font color=Green>Parser1</font> s a <font color="#808080">-&gt;</font> <font color="#808080">(</font>a <font color="#808080">-&gt;</font> <font color=Green>Parser1</font> s b<font color="#808080">)</font> <font color="#808080">-&gt;</font> <font color=Green>Parser1</font> s b

<font color=Blue>-- Final semantics to expose:</font>
<u><font color="#804000">type</font></u> <font color=Green>Semantics</font> s a <font color="#808080">=</font> <font color="#808080">[</font>s<font color="#808080">]</font> <font color="#808080">-&gt;</font> <font color="#808080">[</font><font color="#808080">(</font>a<font color="#808080">,</font><font color="#808080">[</font>s<font color="#808080">]</font><font color="#808080">)</font><font color="#808080">]</font>

<font color=Blue>-- | Reference implementation/Semantics.  (It's easy to see that</font>
<font color=Blue>--   it's what we want, but maybe inefficient.)</font>
run <font color="#808080">::</font> <font color=Green>Parser1</font> s a <font color="#808080">-&gt;</font> <font color=Green>Semantics</font> s a
run <font color=Green>Symbol</font>       <font color="#808080">=</font> symbolS
run <font color=Green>Fail</font>         <font color="#808080">=</font> failS
run <font color="#808080">(</font><font color=Green>Choice</font> p q<font color="#808080">)</font> <font color="#808080">=</font> choiceS <font color="#808080">(</font>run p<font color="#808080">)</font> <font color="#808080">(</font>run q<font color="#808080">)</font>
run <font color="#808080">(</font><font color=Green>Return</font> x<font color="#808080">)</font>   <font color="#808080">=</font> returnS x
run <font color="#808080">(</font>p <b><font color="#800080">:&gt;&gt;=</font></b> f<font color="#808080">)</font>   <font color="#808080">=</font> run p  <font color="#800080">`bindS`</font>  <font color="#808080">(</font>run <font color="#800080">.</font> f<font color="#808080">)</font>

<font color=Blue>{- Starting point:

symbolS :: Semantics s s -- [s] -&gt; [(s, [s])]
symbolS = error "TBD"

failS   :: Semantics s a
failS   = error "TBD

choiceS :: Semantics s a -&gt; Semantics s a -&gt; Semantics s a
choiceS = error "TBD"

returnS :: a -&gt; Semantics s a 
returnS = error "TBD"

bindS   :: Semantics s a -&gt; (a -&gt; Semantics s b) -&gt; Semantics s b
bindS   = error "TBD"

-}</font>

symbolS <font color="#808080">::</font> <font color="#808080">[</font>s<font color="#808080">]</font> <font color="#808080">-&gt;</font> <font color="#808080">[</font><font color="#808080">(</font>s<font color="#808080">,</font> <font color="#808080">[</font>s<font color="#808080">]</font><font color="#808080">)</font><font color="#808080">]</font> <font color=Blue>-- Semantics s s</font>
symbolS <font color=Green>[]</font>      <font color="#808080">=</font> <font color=Green>[]</font>         <font color=Blue>-- no parse</font>
symbolS <font color="#808080">(</font>s<b><font color="#800080">:</font></b>ss<font color="#808080">)</font>  <font color="#808080">=</font> <font color="#808080">[</font><font color="#808080">(</font>s<font color="#808080">,</font> ss<font color="#808080">)</font><font color="#808080">]</font>  <font color=Blue>-- exactly one parse resuls</font>

failS   <font color="#808080">::</font> <font color=Green>Semantics</font> s a
failS <u><font color="#804000">_</font></u> <font color="#808080">=</font> <font color=Green>[]</font>

choiceS <font color="#808080">::</font> <font color="#808080">(</font><font color="#808080">[</font>s<font color="#808080">]</font> <font color="#808080">-&gt;</font> <font color="#808080">[</font><font color="#808080">(</font>a<font color="#808080">,</font> <font color="#808080">[</font>s<font color="#808080">]</font><font color="#808080">)</font><font color="#808080">]</font><font color="#808080">)</font> <font color="#808080">-&gt;</font> <font color=Green>Semantics</font> s a <font color="#808080">-&gt;</font> <font color="#808080">(</font><font color="#808080">[</font>s<font color="#808080">]</font> <font color="#808080">-&gt;</font> <font color="#808080">[</font><font color="#808080">(</font>a<font color="#808080">,</font><font color="#808080">[</font>s<font color="#808080">]</font><font color="#808080">)</font><font color="#808080">]</font><font color="#808080">)</font>
choiceS p q <font color="#808080">=</font> <font color="#808080">\</font>ss <font color="#808080">-&gt;</font> p ss <font color="#800080">++</font> q ss

returnS <font color="#808080">::</font> a <font color="#808080">-&gt;</font> <font color="#808080">[</font>s<font color="#808080">]</font> <font color="#808080">-&gt;</font> <font color="#808080">[</font><font color="#808080">(</font>a<font color="#808080">,</font> <font color="#808080">[</font>s<font color="#808080">]</font><font color="#808080">)</font><font color="#808080">]</font>
returnS x <font color="#808080">=</font> <font color="#808080">\</font>ss <font color="#808080">-&gt;</font> <font color="#808080">[</font><font color="#808080">(</font>x<font color="#808080">,</font> ss<font color="#808080">)</font><font color="#808080">]</font> <font color=Blue>-- exactly one parse, input unchanged</font>

<font color=Blue>-- bindS   :: Semantics s a -&gt; (a -&gt; Semantics s b) -&gt; Semantics s b</font>
<font color=Blue>{-
bindS   :: (      [s] -&gt; [(a, [s])])  -&gt;  -- ^ the parser p
           (a -&gt; ([s] -&gt; [(b, [s])])) -&gt;  -- ^ the function f
                 ([s] -&gt;                  -- ^ the input string
                         [(b, [s])])
-}</font>
<font color=Blue>-- bindS p f = \ss -&gt; concatMap (uncurry f) (p ss)</font>
bindS p f <font color="#808080">=</font> concatMap <font color="#808080">(</font>uncurry f<font color="#808080">)</font> <font color="#800080">.</font> p




<font color=Blue>{-
symbolS :: Semantics s s
symbolS (c : s)  =  [(c, s)]
symbolS []       =  []

failS :: Semantics s a
failS _ = []

choiceS :: Semantics s a -&gt; Semantics s a -&gt; Semantics s a
choiceS left right = \s -&gt; left s ++ right s

returnS :: a -&gt; Semantics s a
returnS x = \s -&gt; [(x, s)]

bindS :: Semantics s a -&gt; (a -&gt; Semantics s b) -&gt; Semantics s b
bindS pa a2pb = concatMap (uncurry a2pb) . pa

bindS' :: Semantics s a -&gt; (a -&gt; Semantics s b) -&gt; Semantics s b
bindS' pa a2pb = \s   -&gt;  let  pas = pa s -- :: [(a, [s])]
                               pbss = map (uncurry a2pb) pas
                          in concat pbss     

bindS'' :: Semantics s a -&gt;(a -&gt; Semantics s b) -&gt; Semantics s b
bindS'' pa a2pb = \s   -&gt;  [(y, s'')  | (x, s')  &lt;- pa s
                                      , (y, s'') &lt;- a2pb x s']

-}</font>
<font color=Blue>{- 

Using this reference semantics we can prove (exercise) a number
of useful laws about parsers. We will use these laws later to
derive an efficient implementation of the library.

  Notation: [| p |] = run p

  For two parsers p and q we define
  
    p == q  iff  ∀ s. [| p |] s == [| q |] s, 
      
      up to the order of elements in the result 
        (list is interpreted as a multiset).

  Monad Laws

    L1.  return x &gt;&gt;= f   ==  f x
    L2.  p &gt;&gt;= return     ==  p
    L3.  (p &gt;&gt;= f) &gt;&gt;= g  ==  p &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)

  More laws about &gt;&gt;=, (+++) and fail

    L4.  fail &gt;&gt;= f       ==  fail
    L5.  (p +++ q) &gt;&gt;= f  ==  (p &gt;&gt;= f) +++ (q &gt;&gt;= f)

  Laws about (+++) and fail

    L6.  fail +++ q       ==  q
    L7.  p +++ fail       ==  p

  Laws about (+++)

    L8.  (p +++ q) +++ r  ==  p +++ (q +++ r)
    L9.  p +++ q          ==  q +++ p           
         -- multisets are important in L9!

  Laws about &gt;&gt;=, (+++) and symbol
  
    L10. (symbol &gt;&gt;= f) +++ (symbol &gt;&gt;= g)
           ==  symbol &gt;&gt;= (\c -&gt; f c +++ g c)

  Here is the proof of L10 for the case of a non-empty input
  string:

       [| (symbol &gt;&gt;= f) +++ (symbol &gt;&gt;= g) |] (c:s)         

  ==  { semantics of (+++) }

       [| symbol &gt;&gt;= f |] (c:s) ++ [| symbol &gt;&gt;= g |] (c:s)  

  ==  { semantics of &gt;&gt;= and symbol }

       [| f c |] s ++ [| g c |] s                   

  ==  { semantics of (+++) }

       [| f c +++ g c |] s                                  

  ==  { semantics of symbol and &gt;&gt;= }

      [| symbol &gt;&gt;= (\x -&gt; f x +++ g x) |] (c:s)

  Exercise: prove or test the laws
-}</font>

<font color=Blue>{- The reference semantics is useful for reasoning, but
   inefficient.  There are three sources of inefficiency that we
   can identify:

   1. The list comprehension builds a lot of intermediate lists
   which might be costly.

   2. List append (++) is linear in its first argument which
   means that left nested appl.s of (+++) get a quadratic
   behaviour.

   3. (+++) is treated in a depth first way, first computing the
   results of the left parser, then computing the results of the
   second parser. This leads to a space leak since we have to
   hang on to the full input string to feed to the second
   parser, while traversing the string with the first parser.
-}</font>

<font color=Blue>-- To solve them we'll invent clever intermediate</font>
<font color=Blue>--   representations.</font>



<font color=Blue>-- Can we linearize sequencing (&gt;&gt;=)? (Would help with 1.)</font>
<u><font color="#804000">data</font></u> <font color=Green>Parser2</font> s a <u><font color="#804000">where</font></u>
    <font color=Green>SymbolBind2</font>  <font color="#808080">::</font>  <font color="#808080">(</font>s <font color="#808080">-&gt;</font> <font color=Green>Parser2</font> s a<font color="#808080">)</font> <font color="#808080">-&gt;</font> <font color=Green>Parser2</font> s a
    <font color=Blue>-- SymbolBind f  ≜  Symbol &gt;&gt;= f</font>
    <font color=Green>Return2</font>      <font color="#808080">::</font>  a <font color="#808080">-&gt;</font> <font color=Green>Parser2</font> s a
    <font color=Green>Choice2</font>      <font color="#808080">::</font>  <font color=Green>Parser2</font> s a <font color="#808080">-&gt;</font> <font color=Green>Parser2</font> s a <font color="#808080">-&gt;</font> <font color=Green>Parser2</font> s a
    <font color=Green>Fail2</font>        <font color="#808080">::</font>  <font color=Green>Parser2</font> s a


run2 <font color="#808080">::</font> <font color=Green>Parser2</font> s a <font color="#808080">-&gt;</font> <font color=Green>Semantics</font> s a
run2 <font color="#808080">(</font><font color=Green>SymbolBind2</font> f<font color="#808080">)</font>  <font color="#808080">=</font> symbolBind2S <font color="#808080">(</font><font color="#808080">\</font>s <font color="#808080">-&gt;</font> run2 <font color="#808080">(</font>f s<font color="#808080">)</font><font color="#808080">)</font>
run2 <font color="#808080">(</font><font color=Green>Return2</font> y<font color="#808080">)</font>      <font color="#808080">=</font> returnS y
run2 <font color="#808080">(</font><font color=Green>Choice2</font> p q<font color="#808080">)</font>    <font color="#808080">=</font> choiceS <font color="#808080">(</font>run2 p<font color="#808080">)</font> <font color="#808080">(</font>run2 q<font color="#808080">)</font>
run2 <font color=Green>Fail2</font>            <font color="#808080">=</font> failS

symbolBind2S <font color="#808080">::</font> <font color="#808080">(</font>s <font color="#808080">-&gt;</font> <font color=Green>Semantics</font> s a<font color="#808080">)</font> <font color="#808080">-&gt;</font> <font color=Green>Semantics</font> s a
symbolBind2S f <font color=Green>[]</font>      <font color="#808080">=</font>  <font color=Green>[]</font>
symbolBind2S f <font color="#808080">(</font>x<b><font color="#800080">:</font></b>xs<font color="#808080">)</font>  <font color="#808080">=</font>  f x xs 

symbolBind2S' <font color="#808080">::</font> <font color="#808080">(</font>s <font color="#808080">-&gt;</font> <font color=Green>Semantics</font> s a<font color="#808080">)</font> <font color="#808080">-&gt;</font> <font color=Green>Semantics</font> s a
symbolBind2S' f <font color="#808080">=</font> symbolS  <font color="#800080">`bindS`</font>  f

<font color=Blue>{- 

  symbolS  `bindS`  f  

= { def. of bindS }
  
concatMap (uncurry f) . symbolS

= { def. of symbolS }

  \cs -&gt; case cs of  []       -&gt; concatMap (uncurry f) []
                     (c : s)  -&gt; concatMap (uncurry f) [(c, s)]

= { concatMap lemmas  }

  \cs -&gt; case cs of  []       -&gt; []
                     (c : s)  -&gt; uncurry f (c, s)

= { def. of uncurry }

  \cs -&gt; case cs of  []       -&gt; []
                     (c : s)  -&gt; f c s
-}</font>


<font color=Blue>-- It turns out that we can also translate Parser1 into Parser2.</font>
p12 <font color="#808080">::</font> <font color=Green>Parser1</font> s a <font color="#808080">-&gt;</font> <font color=Green>Parser2</font> s a
p12 <font color=Green>Symbol</font>      <font color="#808080">=</font>  <font color=Green>SymbolBind2</font> <font color=Green>Return2</font> <font color=Blue>-- L1</font>
p12 <font color=Green>Fail</font>        <font color="#808080">=</font>  <font color=Green>Fail2</font>
p12 <font color="#808080">(</font><font color=Green>Choice</font> p q<font color="#808080">)</font><font color="#808080">=</font>  <font color=Green>Choice2</font> <font color="#808080">(</font>p12 p<font color="#808080">)</font> <font color="#808080">(</font>p12 q<font color="#808080">)</font>
p12 <font color="#808080">(</font><font color=Green>Return</font> y<font color="#808080">)</font>  <font color="#808080">=</font>  <font color=Green>Return2</font> y 
p12 <font color="#808080">(</font><font color=Green>Symbol</font>      <b><font color="#800080">:&gt;&gt;=</font></b> k<font color="#808080">)</font>  <font color="#808080">=</font>  <font color=Green>SymbolBind2</font> <font color="#808080">(</font>p12 <font color="#800080">.</font> k<font color="#808080">)</font> 
                            <font color=Blue>-- def of SymbolBind</font>
p12 <font color="#808080">(</font><font color=Green>Fail</font>        <b><font color="#800080">:&gt;&gt;=</font></b> k<font color="#808080">)</font>  <font color="#808080">=</font>  <font color=Green>Fail2</font> 
                            <font color=Blue>-- Parser law. L4.</font>
p12 <font color="#808080">(</font><font color="#808080">(</font><font color=Green>Choice</font> p q<font color="#808080">)</font><b><font color="#800080">:&gt;&gt;=</font></b> k<font color="#808080">)</font>  <font color="#808080">=</font>  <font color=Green>Choice2</font> <font color="#808080">(</font>p12 <font color="#808080">(</font>p <b><font color="#800080">:&gt;&gt;=</font></b> k<font color="#808080">)</font><font color="#808080">)</font>
                                     <font color="#808080">(</font>p12 <font color="#808080">(</font>q <b><font color="#800080">:&gt;&gt;=</font></b> k<font color="#808080">)</font><font color="#808080">)</font>
                            <font color=Blue>-- Parser law. L5</font>
p12 <font color="#808080">(</font><font color=Green>Return</font> y    <b><font color="#800080">:&gt;&gt;=</font></b> k<font color="#808080">)</font>  <font color="#808080">=</font>  p12 <font color="#808080">(</font>k y<font color="#808080">)</font> 
                            <font color=Blue>-- monad law, L1</font>
p12 <font color="#808080">(</font><font color="#808080">(</font>p <b><font color="#800080">:&gt;&gt;=</font></b> k'<font color="#808080">)</font> <b><font color="#800080">:&gt;&gt;=</font></b> k<font color="#808080">)</font>  <font color="#808080">=</font>  p12 <font color="#808080">(</font>p <b><font color="#800080">:&gt;&gt;=</font></b> <font color="#808080">(</font><font color="#808080">\</font>x <font color="#808080">-&gt;</font> k' x <b><font color="#800080">:&gt;&gt;=</font></b> k<font color="#808080">)</font><font color="#808080">)</font> 
                            <font color=Blue>-- monad law, L3</font>

<font color=Blue>-- Can we linearize choice as well (+++)?</font>
<u><font color="#804000">data</font></u> <font color=Green>Parser3</font> s a <u><font color="#804000">where</font></u>
    <font color=Green>SymbolBind3</font>    <font color="#808080">::</font>  <font color="#808080">(</font>s <font color="#808080">-&gt;</font> <font color=Green>Parser3</font> s a<font color="#808080">)</font> <font color="#808080">-&gt;</font> <font color=Green>Parser3</font> s a
    <font color=Green>ReturnChoice3</font>  <font color="#808080">::</font>  a <font color="#808080">-&gt;</font> <font color=Green>Parser3</font> s a   <font color="#808080">-&gt;</font> <font color=Green>Parser3</font> s a 
    <font color=Blue>-- ReturnChoice x p  ≜  Return x +++ p</font>
    <font color=Green>Fail3</font>          <font color="#808080">::</font>  <font color=Green>Parser3</font> s a

run3 <font color="#808080">::</font> <font color=Green>Parser3</font> s a <font color="#808080">-&gt;</font> <font color=Green>Semantics</font> s a
run3 <font color="#808080">(</font><font color=Green>SymbolBind3</font> f<font color="#808080">)</font>      <font color=Green>[]</font>        <font color="#808080">=</font>  <font color=Green>[]</font>
run3 <font color="#808080">(</font><font color=Green>SymbolBind3</font> f<font color="#808080">)</font>      <font color="#808080">(</font>s <b><font color="#800080">:</font></b> ss<font color="#808080">)</font>  <font color="#808080">=</font>  run3 <font color="#808080">(</font>f s<font color="#808080">)</font> ss
run3 <font color="#808080">(</font><font color=Green>ReturnChoice3</font> x p<font color="#808080">)</font>  l         <font color="#808080">=</font>  <font color="#808080">(</font>x <font color="#808080">,</font> l<font color="#808080">)</font> <b><font color="#800080">:</font></b> run3 p l 
                                <font color=Blue>-- ~= run (Return x +++ p)</font>
run3 <font color=Green>Fail3</font>                l         <font color="#808080">=</font>  <font color=Green>[]</font>

<font color=Blue>-- But it turns out that we can translate 2 into 3!</font>
p23 <font color="#808080">::</font> <font color=Green>Parser2</font> s a <font color="#808080">-&gt;</font> <font color=Green>Parser3</font> s a
p23 <font color="#808080">(</font><font color=Green>SymbolBind2</font> f<font color="#808080">)</font>  <font color="#808080">=</font>  <font color=Green>SymbolBind3</font> <font color="#808080">(</font>p23 <font color="#800080">.</font> f<font color="#808080">)</font>
p23 <font color="#808080">(</font><font color=Green>Return2</font> x<font color="#808080">)</font>      <font color="#808080">=</font>  <font color=Green>ReturnChoice3</font> x <font color=Green>Fail3</font> 
                        <font color=Blue>-- def. of ReturnChoice</font>
p23 <font color="#808080">(</font><font color=Green>Choice2</font> p q<font color="#808080">)</font>    <font color="#808080">=</font>  best <font color="#808080">(</font>p23 p<font color="#808080">)</font> <font color="#808080">(</font>p23 q<font color="#808080">)</font>
p23 <font color=Green>Fail2</font>            <font color="#808080">=</font>  <font color=Green>Fail3</font>

best <font color="#808080">::</font> <font color=Green>Parser3</font> s a <font color="#808080">-&gt;</font> <font color=Green>Parser3</font> s a <font color="#808080">-&gt;</font> <font color=Green>Parser3</font> s a
best <font color="#808080">(</font><font color=Green>SymbolBind3</font> f<font color="#808080">)</font>      <font color="#808080">(</font><font color=Green>SymbolBind3</font> g<font color="#808080">)</font>     <font color=Blue>-- L10</font>
  <font color="#808080">=</font> <font color=Green>SymbolBind3</font> <font color="#808080">(</font><font color="#808080">\</font>s <font color="#808080">-&gt;</font> best <font color="#808080">(</font>f s<font color="#808080">)</font> <font color="#808080">(</font>g s<font color="#808080">)</font><font color="#808080">)</font>   
best p                    <font color="#808080">(</font><font color=Green>ReturnChoice3</font> x q<font color="#808080">)</font> <font color=Blue>-- L8 (+++ commut)</font>
  <font color="#808080">=</font> <font color=Green>ReturnChoice3</font> x <font color="#808080">(</font>best p q<font color="#808080">)</font>             
best <font color="#808080">(</font><font color=Green>ReturnChoice3</font> x q<font color="#808080">)</font>  p                   <font color=Blue>-- L9 (+++ assoc)</font>
  <font color="#808080">=</font> <font color=Green>ReturnChoice3</font> x <font color="#808080">(</font>best p q<font color="#808080">)</font>
best p <font color=Green>Fail3</font> <font color="#808080">=</font> p   <font color=Blue>-- L6</font>
best <font color=Green>Fail3</font> q <font color="#808080">=</font> q   <font color=Blue>-- L7</font>


<font color=Blue>-- | Efficient implementation for general syntax:</font>
parse <font color="#808080">::</font> <font color=Green>P</font> s a <font color="#808080">-&gt;</font> <font color=Green>Semantics</font> s a
parse <font color="#808080">=</font> run3 <font color="#800080">.</font> p23 <font color="#800080">.</font> p12

<font color=Blue>-- we could show formally: </font>
<font color=Blue>-- (x , s) ∈ run  p ss  &lt;=&gt;  (x , s) ∈ run2 (p12 p) ss</font>
<font color=Blue>-- (x , s) ∈ run2 p ss  &lt;=&gt;  (x , s) ∈ run3 (p23 p) ss</font>

<font color=Blue>-- and therefore:</font>
<font color=Blue>-- (x , s) ∈ run p ss   &lt;=&gt;  (x , s) ∈ parse p ss</font>

<font color=Blue>-- Exercise: prove or test</font>


<font color=Blue>{----------------------
 NOTES:

* L4 to L10 are "parser laws", expected to hold of any
  well-behaved parser.

-}</font>
</pre>
</body>
</html>