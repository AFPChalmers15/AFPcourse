<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>lectures/lecture5/Interpreter2.hs</title>
</head>
<body>
<pre><font color=Blue>{-# LANGUAGE GeneralizedNewtypeDeriving #-}</font>
<font color=Blue>-- | Version 2 of the interpreter</font>
<u><font color="#804000">module</font></u> <font color=Green>Interpreter2</font> <u><font color="#804000">where</font></u>

<u><font color="#804000">import</font></u> <u><font color="#804000">qualified</font></u> <font color=Green>Control</font><font color="#800080">.</font><font color=Green>Monad</font>          <u><font color="#804000">as</font></u> <font color=Green>CM</font>
<u><font color="#804000">import</font></u> <u><font color="#804000">qualified</font></u> <font color=Green>Control</font><font color="#800080">.</font><font color=Green>Monad</font><font color="#800080">.</font><font color=Green>Identity</font> <u><font color="#804000">as</font></u> <font color=Green>CMI</font>
<u><font color="#804000">import</font></u> <u><font color="#804000">qualified</font></u> <font color=Green>Control</font><font color="#800080">.</font><font color=Green>Monad</font><font color="#800080">.</font><font color=Green>Reader</font>   <u><font color="#804000">as</font></u> <font color=Green>CMR</font>
<u><font color="#804000">import</font></u> <u><font color="#804000">qualified</font></u> <font color=Green>Control</font><font color="#800080">.</font><font color=Green>Monad</font><font color="#800080">.</font><font color=Green>State</font>    <u><font color="#804000">as</font></u> <font color=Green>CMS</font> <font color=Blue>-- new</font>

<u><font color="#804000">import</font></u> <font color=Green>Data</font><font color="#800080">.</font><font color=Green>Map</font> <font color="#808080">(</font><font color=Green>Map</font><font color="#808080">)</font>
<u><font color="#804000">import</font></u> <u><font color="#804000">qualified</font></u> <font color=Green>Data</font><font color="#800080">.</font><font color=Green>Map</font> <u><font color="#804000">as</font></u> <font color=Green>Map</font>

<u><font color="#804000">import</font></u> <u><font color="#804000">qualified</font></u> <font color=Green>Parser</font> <u><font color="#804000">as</font></u> <font color=Green>P</font> <font color="#808080">(</font>parseExpr<font color="#808080">,</font> <font color=Green>Language</font> <font color="#808080">(</font><font color="#808080">..</font><font color="#808080">)</font><font color="#808080">)</font>

<font color=Blue>-- | Even more interesting stuff: mutable references!</font>
<u><font color="#804000">data</font></u> <font color=Green>Expr</font> <font color="#808080">=</font> <font color=Green>Lit</font> <font color=Green>Integer</font>
          <font color="#808080">|</font> <font color=Green>Expr</font> <b><font color="#800080">:+</font></b> <font color=Green>Expr</font>
          <font color="#808080">|</font> <font color=Green>Var</font> <font color=Green>Name</font>
          <font color="#808080">|</font> <font color=Green>Let</font> <font color=Green>Name</font> <font color=Green>Expr</font> <font color=Green>Expr</font>
          <font color="#808080">|</font> <font color=Green>NewRef</font> <font color=Green>Expr</font>         <font color=Blue>-- new</font>
          <font color="#808080">|</font> <font color=Green>Deref</font> <font color=Green>Expr</font>          <font color=Blue>-- new</font>
          <font color="#808080">|</font> <font color=Green>Expr</font> <b><font color="#800080">:=</font></b> <font color=Green>Expr</font>        <font color=Blue>-- new</font>
  <u><font color="#804000">deriving</font></u> <font color="#808080">(</font><font color=Green>Show</font><font color="#808080">)</font>

<u><font color="#804000">type</font></u> <font color=Green>Name</font>   <font color="#808080">=</font> <font color=Green>String</font>
<u><font color="#804000">type</font></u> <font color=Green>Value</font>  <font color="#808080">=</font> <font color=Green>Integer</font>
<u><font color="#804000">type</font></u> <font color=Green>Ptr</font>    <font color="#808080">=</font> <font color=Green>Value</font>
  <font color=Blue>-- ^ dangerous language: any 'Value' can be used as a 'Ptr'</font>

<font color=Blue>-- | An environment maps variables to values.</font>
<u><font color="#804000">type</font></u> <font color=Green>Env</font> <font color="#808080">=</font> <font color=Green>Map</font> <font color=Green>Name</font> <font color=Green>Value</font>

emptyEnv <font color="#808080">::</font> <font color=Green>Env</font>
emptyEnv <font color="#808080">=</font> <font color=Green>Map</font><font color="#800080">.</font>empty

<font color=Blue>-- | We need to keep track of the store containing the values of</font>
<font color=Blue>-- our references. We also remember the next unused pointer.</font>
<u><font color="#804000">data</font></u> <font color=Green>Store</font> <font color="#808080">=</font> <font color=Green>Store</font> <font color="#808080">{</font> nextPtr <font color="#808080">::</font> <font color=Green>Ptr</font>
                   <font color="#808080">,</font> heap    <font color="#808080">::</font> <font color=Green>Map</font> <font color=Green>Ptr</font> <font color=Green>Value</font>
                   <font color="#808080">}</font>

emptyStore <font color="#808080">::</font> <font color=Green>Store</font>
emptyStore <font color="#808080">=</font> <font color=Green>Store</font> <font color=Magenta>0</font> <font color=Green>Map</font><font color="#800080">.</font>empty

<font color=Blue>-- | The store needs to be updated globally in a program so we</font>
<font color=Blue>-- use a state monad to pass the store around.</font>

<u><font color="#804000">newtype</font></u> <font color=Green>Eval</font> a <font color="#808080">=</font> <font color=Green>Eval</font> <font color="#808080">{</font> unEval <font color="#808080">::</font> <font color=Green>CMS</font><font color="#800080">.</font><font color=Green>StateT</font> <font color=Green>Store</font>
                                    <font color="#808080">(</font><font color=Green>CMR</font><font color="#800080">.</font><font color=Green>ReaderT</font> <font color=Green>Env</font>
                                      <font color=Green>CMI</font><font color="#800080">.</font><font color=Green>Identity</font><font color="#808080">)</font>
                                        a <font color="#808080">}</font>
  <u><font color="#804000">deriving</font></u> <font color="#808080">(</font><font color=Green>Monad</font><font color="#808080">,</font>  <font color=Green>CMS</font><font color="#800080">.</font><font color=Green>MonadState</font> <font color=Green>Store</font><font color="#808080">,</font>
                    <font color=Green>CMR</font><font color="#800080">.</font><font color=Green>MonadReader</font> <font color=Green>Env</font>  <font color="#808080">)</font>
<font color=Blue>{- ^ Explaining and expanding the type
  CMS.StateT s m' a  ~=  s -&gt; m' (a, s)
  CMR.ReaderT e m a  ~=  e -&gt; m a
  CMI.Identity a     ~=  a
  =&gt; Eval a  ~=
     s -&gt; m' (a, s)     ~= {- where m' = CMR.ReaderT Env m -}
     s -&gt; e -&gt; m (a,s)  ~= {- where m  = CMI.Identity      -}
     s -&gt; e -&gt; (a,s)
-}</font>

runEval <font color="#808080">::</font> <font color=Green>Eval</font> a <font color="#808080">-&gt;</font> a
runEval <font color="#808080">=</font> <font color=Green>CMI</font><font color="#800080">.</font>runIdentity
        <font color="#800080">.</font> startReaderFrom emptyEnv
        <font color="#800080">.</font> startStateFrom  emptyStore
        <font color="#800080">.</font> unEval

startStateFrom <font color="#808080">::</font> <font color=Green>Monad</font> m <font color="#808080">=&gt;</font> state <font color="#808080">-&gt;</font> <font color=Green>CMS</font><font color="#800080">.</font><font color=Green>StateT</font> state m a <font color="#808080">-&gt;</font> m a
startStateFrom <font color="#808080">=</font> flip <font color=Green>CMS</font><font color="#800080">.</font>evalStateT
  <font color=Blue>-- &gt; CMS.evalStateT :: Monad m =&gt; CMS.StateT state m a -&gt;</font>
  <font color=Blue>-- &gt;                                (state -&gt; m a)</font>

startReaderFrom <font color="#808080">::</font> env <font color="#808080">-&gt;</font> <font color=Green>CMR</font><font color="#800080">.</font><font color=Green>ReaderT</font> env m a <font color="#808080">-&gt;</font> m a
startReaderFrom <font color="#808080">=</font> flip <font color=Green>CMR</font><font color="#800080">.</font>runReaderT
  <font color=Blue>-- &gt; CMR.runReaderT :: CMR.ReaderT env m a -&gt;</font>
  <font color=Blue>-- &gt;                              (env -&gt; m a)</font>

<font color=Blue>-- * Environment manipulation</font>
<font color=Blue>--   No changes necessary from 'Interpreter1'</font>

<font color=Blue>-- | Looking up the value of a variable in the enviroment.</font>
lookupVar <font color="#808080">::</font> <font color=Green>Name</font> <font color="#808080">-&gt;</font> <font color=Green>Eval</font> <font color=Green>Value</font>
lookupVar x <font color="#808080">=</font> <u><font color="#804000">do</font></u>
  env <font color="#808080">&lt;-</font> <font color=Green>CMR</font><font color="#800080">.</font>ask
  <u><font color="#804000">case</font></u> <font color=Green>Map</font><font color="#800080">.</font>lookup x env <u><font color="#804000">of</font></u>
    <font color=Green>Nothing</font> <font color="#808080">-&gt;</font> fail <font color="#808080">(</font><font color=Magenta>"lookupVar: unbound variable: "</font> <font color="#800080">++</font> x<font color="#808080">)</font>
    <font color=Green>Just</font> v  <font color="#808080">-&gt;</font> return v

extendEnv <font color="#808080">::</font> <font color=Green>Name</font> <font color="#808080">-&gt;</font> <font color=Green>Value</font> <font color="#808080">-&gt;</font> <font color=Green>Eval</font> a <font color="#808080">-&gt;</font> <font color=Green>Eval</font> a
extendEnv x v <font color="#808080">=</font> <font color=Green>CMR</font><font color="#800080">.</font>local <font color="#808080">(</font><font color=Green>Map</font><font color="#800080">.</font>insert x v<font color="#808080">)</font>

<font color=Blue>-- * Store manipulation (new)</font>

<font color=Blue>-- | Create a new reference containing the given value.</font>
newRef <font color="#808080">::</font> <font color=Green>Value</font> <font color="#808080">-&gt;</font> <font color=Green>Eval</font> <font color=Green>Ptr</font>
newRef v <font color="#808080">=</font> <u><font color="#804000">do</font></u>
  s <font color="#808080">&lt;-</font> <font color=Green>CMS</font><font color="#800080">.</font>get
  <u><font color="#804000">let</font></u> ptr <font color="#808080">=</font> nextPtr s
      s'  <font color="#808080">=</font> s <font color="#808080">{</font> nextPtr <font color="#808080">=</font> ptr <font color="#800080">+</font> <font color=Magenta>1</font>
              <font color="#808080">,</font> heap    <font color="#808080">=</font> <font color=Green>Map</font><font color="#800080">.</font>insert ptr v <font color="#808080">(</font>heap s<font color="#808080">)</font>
              <font color="#808080">}</font>
  <font color=Green>CMS</font><font color="#800080">.</font>put s'
  return ptr


<font color=Blue>-- | Get the value of a reference. Crashes with our own</font>
<font color=Blue>-- "segfault" if given a non-existing pointer.</font>
deref <font color="#808080">::</font> <font color=Green>Ptr</font> <font color="#808080">-&gt;</font> <font color=Green>Eval</font> <font color=Green>Value</font>
deref p <font color="#808080">=</font> <u><font color="#804000">do</font></u>
  h <font color="#808080">&lt;-</font> <font color=Green>CMS</font><font color="#800080">.</font>gets heap <font color=Blue>-- remember *heap :: Store -&gt; Map Ptr Value*</font>
  <u><font color="#804000">case</font></u> <font color=Green>Map</font><font color="#800080">.</font>lookup p h <u><font color="#804000">of</font></u>
    <font color=Green>Nothing</font> <font color="#808080">-&gt;</font> fail <font color=Magenta>"deref: segmentation fault"</font>
    <font color=Green>Just</font> v  <font color="#808080">-&gt;</font> return v

<font color=Blue>-- | Updating the value of a reference. Has no effect if the</font>
<font color=Blue>-- reference doesn't exist. (Exercise: Maybe that's not the best</font>
<font color=Blue>-- semantics... what would be a better one?)</font>
<font color="#808080">(</font><font color="#800080">=:</font><font color="#808080">)</font> <font color="#808080">::</font> <font color=Green>Ptr</font> <font color="#808080">-&gt;</font> <font color=Green>Value</font> <font color="#808080">-&gt;</font> <font color=Green>Eval</font> <font color=Green>Value</font>
p <font color="#800080">=:</font> v <font color="#808080">=</font> <u><font color="#804000">do</font></u>
  <font color=Green>CMS</font><font color="#800080">.</font>modify <font color="#800080">$</font> <font color="#808080">\</font>s <font color="#808080">-&gt;</font> s <font color="#808080">{</font> heap <font color="#808080">=</font> <font color=Green>Map</font><font color="#800080">.</font>adjust <font color="#808080">(</font>const v<font color="#808080">)</font> p <font color="#808080">(</font>heap s<font color="#808080">)</font> <font color="#808080">}</font>
  return v
<font color=Blue>-- Map.adjust :: (Ord k) =&gt; (a -&gt; a) -&gt; k -&gt; Map k a -&gt; Map k a</font>

<font color=Blue>-- | As before we only need to add cases for the new con-</font>
<font color=Blue>-- structors to the evaluator. No need to change the old stuff.</font>
eval <font color="#808080">::</font> <font color=Green>Expr</font> <font color="#808080">-&gt;</font> <font color=Green>Eval</font> <font color=Green>Value</font>
eval <font color="#808080">(</font><font color=Green>Lit</font> n<font color="#808080">)</font>        <font color="#808080">=</font> return n
eval <font color="#808080">(</font>a <b><font color="#800080">:+</font></b> b<font color="#808080">)</font>       <font color="#808080">=</font> <font color=Green>CM</font><font color="#800080">.</font>liftM2 <font color="#808080">(</font><font color="#800080">+</font><font color="#808080">)</font> <font color="#808080">(</font>eval a<font color="#808080">)</font> <font color="#808080">(</font>eval b<font color="#808080">)</font>
eval <font color="#808080">(</font><font color=Green>Var</font> x<font color="#808080">)</font>        <font color="#808080">=</font> lookupVar x
eval <font color="#808080">(</font><font color=Green>Let</font> x e1 e2<font color="#808080">)</font>  <font color="#808080">=</font> <u><font color="#804000">do</font></u>
  v1 <font color="#808080">&lt;-</font> eval e1
  extendEnv x v1 <font color="#808080">(</font>eval e2<font color="#808080">)</font>
eval <font color="#808080">(</font><font color=Green>NewRef</font> e<font color="#808080">)</font>     <font color="#808080">=</font> newRef <font color="#800080">=&lt;&lt;</font> eval e    <font color=Blue>-- new</font>
eval <font color="#808080">(</font><font color=Green>Deref</font> e<font color="#808080">)</font>      <font color="#808080">=</font> deref  <font color="#800080">=&lt;&lt;</font> eval e    <font color=Blue>-- new</font>
eval <font color="#808080">(</font>pe <b><font color="#800080">:=</font></b> ve<font color="#808080">)</font>     <font color="#808080">=</font> <u><font color="#804000">do</font></u>                   <font color=Blue>-- new</font>
  p <font color="#808080">&lt;-</font> eval pe
  v <font color="#808080">&lt;-</font> eval ve
  p <font color="#800080">=:</font> v

<font color=Blue>-- * Utilities: testing and parsing</font>

testExercise <font color="#808080">=</font> parse <font color=Magenta>"p:=0"</font>
testUgly <font color="#808080">=</font> parse <font color=Magenta>"let p=new 1; let q=new 1738; !(p+1)"</font>
test <font color="#808080">=</font> runEval <font color="#800080">$</font> eval testUgly

<font color=Blue>-- | The parser is parameterised over the abstract syntax.</font>
language <font color="#808080">=</font> <font color=Green>P</font><font color="#800080">.</font><font color=Green>Lang</font>
  <font color="#808080">{</font> <font color=Green>P</font><font color="#800080">.</font>lLit    <font color="#808080">=</font> <font color=Green>Lit</font>
  <font color="#808080">,</font> <font color=Green>P</font><font color="#800080">.</font>lPlus   <font color="#808080">=</font> <font color="#808080">(</font><b><font color="#800080">:+</font></b><font color="#808080">)</font>
  <font color="#808080">,</font> <font color=Green>P</font><font color="#800080">.</font>lLet    <font color="#808080">=</font> <font color=Green>Let</font>
  <font color="#808080">,</font> <font color=Green>P</font><font color="#800080">.</font>lVar    <font color="#808080">=</font> <font color=Green>Var</font>
  <font color="#808080">,</font> <font color=Green>P</font><font color="#800080">.</font>lNewref <font color="#808080">=</font> <font color=Green>NewRef</font>
  <font color="#808080">,</font> <font color=Green>P</font><font color="#800080">.</font>lDeref  <font color="#808080">=</font> <font color=Green>Deref</font>
  <font color="#808080">,</font> <font color=Green>P</font><font color="#800080">.</font>lAssign <font color="#808080">=</font> <font color="#808080">(</font><b><font color="#800080">:=</font></b><font color="#808080">)</font>
  <font color="#808080">,</font> <font color=Green>P</font><font color="#800080">.</font>lCatch  <font color="#808080">=</font> <font color="#808080">\</font><u><font color="#804000">_</font></u> <u><font color="#804000">_</font></u> <font color="#808080">-&gt;</font> <font color=Green>Var</font> <font color=Magenta>"language: not implemented: catch"</font>
  <font color="#808080">}</font>

parse s <font color="#808080">=</font> <u><font color="#804000">case</font></u> <font color=Green>P</font><font color="#800080">.</font>parseExpr language s <u><font color="#804000">of</font></u>
  <font color=Green>Left</font> err <font color="#808080">-&gt;</font> error <font color="#808080">(</font>show err<font color="#808080">)</font>
  <font color=Green>Right</font> x  <font color="#808080">-&gt;</font> x
</pre>
</body>
</html>